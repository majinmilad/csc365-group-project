import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np
import pandas as pd
import random, time
import string

def generate_playlist_name():
    """Generates a random playlist name."""

    moods = ["Chill", "Upbeat", "Romantic", "Nostalgic", "Energetic", "Mellow"]
    genres = ["Pop", "Rock", "Indie", "Hip Hop", "Jazz", "Electronic", "Classical"]
    adjectives = ["Sunny", "Groovy", "Epic", "Dreamy", "Soulful", "Funky"]

    mood = random.choice(moods)
    genre = random.choice(genres)
    adjective = random.choice(adjectives)

    formats = [
        f"{mood} {genre} Vibes",
        f"{adjective} {genre} Beats",
        f"{mood} for {genre} Lovers",
        f"{mood} {genre} Mixtape",
        f"{genre} {adjective} Anthems"
    ]

    return random.choice(formats)


def database_connection_url():
    dotenv.load_dotenv()
    DB_USER: str = os.environ.get("POSTGRES_USER")
    DB_PASSWD = os.environ.get("POSTGRES_PASSWORD")
    DB_SERVER: str = os.environ.get("POSTGRES_SERVER")
    DB_PORT: str = os.environ.get("POSTGRES_PORT")
    DB_NAME: str = os.environ.get("POSTGRES_DB")
    return f"postgresql://{DB_USER}:{DB_PASSWD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

def follower_sample_distribution(num_users:int, total_playlists:int):
        # User Engagement
        avgerage_user_follows = 5
        engagement_rate = ((avgerage_user_follows/total_playlists)**2)*(num_users)

        # Current Top 50
        top_plays = min(10, total_playlists)
        chart = min(40, total_playlists-top_plays)

        # Distribution
        gen_prob = np.random.default_rng().binomial(n=num_users, p=engagement_rate, size=total_playlists-(chart+top_plays)).astype(int)
        chart_prob = np.random.default_rng().binomial(n=num_users, p=.1, size=chart)
        top_prob = np.random.default_rng().binomial(n=num_users, p=.6, size=top_plays)
        follower_sample_distribution = np.concatenate([gen_prob, chart_prob, top_prob]).astype(int)
        return follower_sample_distribution

def playlist_sample_distribution(num_users:int):
    # Split Free & Premium
    num_premium_users = round(.4*num_users)
    num_free_users = round(.6*num_users)

    # Distibution of Premium users Accounting for "Super Users" w/ over 40 playlists
    normal_part = np.random.normal(loc=25, scale=15, size=round(.8*num_premium_users))
    exponential_tail = np.random.exponential(scale=20, size=round(.2*num_premium_users)) + 40  # Shift to start near 40

    # Combine the two parts of the distribution
    data = np.concatenate([normal_part, exponential_tail])
    data[data < 0] = 0
    data = data.astype(int)

    # Account for Free Users
    zeros = [0]*int(num_free_users)
    adj_data = data.tolist() + zeros

    playlist_sample_distribution = adj_data # Goal is a mean # of Playlists of ~12.8
    return playlist_sample_distribution 

print("creating tables...")
with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS "user_account" CASCADE;
    DROP TABLE IF EXISTS "playlist" CASCADE;
    DROP TABLE IF EXISTS "playlist_song" CASCADE;
    DROP TABLE IF EXISTS "playlist_collaborator" CASCADE;
    DROP TABLE IF EXISTS "playlist_follower" CASCADE;
    DROP TABLE IF EXISTS "song" CASCADE;
    DROP TABLE IF EXISTS "album" CASCADE;
    DROP TABLE IF EXISTS "artist" CASCADE;  
    
    CREATE TABLE IF NOT EXISTS
    public.artist (
        artist_id bigint generated by default as identity not null,
        name text null,
        created_at timestamp with time zone not null default now(),
        constraint artist_pkey primary key (artist_id),
        constraint artist_name_key unique (name)
    ) tablespace pg_default;

    CREATE TABLE IF NOT EXISTS
    public.album (
        album_id bigint generated by default as identity not null,
        title text null,
        artist_id bigint null,
        created_at timestamp with time zone not null default now(),
        constraint album_pkey primary key (album_id),
        constraint album_title_key unique (title),
        constraint album_artist_id_fkey foreign key (artist_id) references artist (artist_id)
    ) tablespace pg_default;

    CREATE TABLE IF NOT EXISTS
    public.song (
        song_id bigint generated by default as identity not null,
        title text null,
        duration integer null,
        created_at timestamp with time zone not null default now(),
        album_id bigint not null,
        artist_id integer not null,
        constraint songs_pkey primary key (song_id),
        constraint song_album_id_fkey foreign key (album_id) references album (album_id),
        constraint song_artist_id_fkey foreign key (artist_id) references artist (artist_id)
    ) tablespace pg_default;
                                 
    CREATE TABLE
    public.user_account (
        user_id bigint generated by default as identity not null,
        first_name text null,
        last_name text null,
        created_at timestamp with time zone not null default now(),
        ssn integer null,
        constraint user_pkey primary key (user_id),
        constraint user_user_id_key unique (user_id)
    ) tablespace pg_default;
                                    
                                    
    CREATE TABLE
    public.playlist (
        playlist_id bigint generated by default as identity not null,
        user_id bigint not null,
        playlist_name text not null,
        created_at timestamp with time zone not null default now(),
        constraint playlist_pkey primary key (playlist_id),
        constraint playlist_playlist_id_key unique (playlist_id),
        constraint playlists_user_id_fkey foreign key (user_id) references user_account (user_id) on update cascade on delete cascade
    ) tablespace pg_default;
                                    
    CREATE TABLE
    public.playlist_song (
        id bigint generated by default as identity not null,
        song_id bigint not null,
        playlist_id bigint not null,
        created_at timestamp with time zone not null default now(),
        constraint playlist_song_pkey primary key (id),
        constraint playlist_song_playlist_id_fkey foreign key (playlist_id) references playlist (playlist_id) on update cascade on delete cascade,
        constraint playlist_songs_song_id_fkey foreign key (song_id) references song (song_id) on update cascade on delete cascade
    ) tablespace pg_default;

    create table
    public.playlist_collaborator (
        playlist_id bigint not null,
        user_id bigint not null,
        created_at timestamp with time zone not null default now(),
        constraint playlist_collaborators_pkey primary key (playlist_id, user_id),
        constraint playlist_collaborator_playlist_id_fkey foreign key (playlist_id) references playlist (playlist_id) on update cascade on delete cascade,
        constraint playlist_collaborators_user_id_fkey foreign key (user_id) references user_account (user_id) on update cascade on delete cascade
    ) tablespace pg_default;
                                 
    create table
    public.playlist_follower (
        user_id bigint not null,
        playlist_id bigint not null,
        created_at timestamp with time zone not null default now(),
        constraint follow_playlist_pkey primary key (user_id, playlist_id),
        constraint follow_playlist_playlist_id_fkey foreign key (playlist_id) references playlist (playlist_id) on update cascade on delete cascade,
        constraint follow_playlist_user_id_fkey foreign key (user_id) references user_account (user_id) on update cascade on delete cascade
    ) tablespace pg_default;
    """))
print("done\n")

num_users = 10000
fake = Faker()

# create fake data
with engine.begin() as conn:
    print("Total users: ", num_users)
    print()

    print("creating songs...")
    total_songs = 23630
    song_list = []
    df = pd.read_csv('endpoint_testing/cleaned_song_data.csv')
    for song in df.to_dict('records'):
        song_list.append(
            {
                'name': song['Song'],
                'album': song['spotify_track_album'],
                'artist': song['Performer'],
                'duration': str(song['spotify_track_duration_ms']//1000) + 's'
            }
        )

        song['name'] = song['Song']
        song['album'] = song['spotify_track_album']
        song['artist'] = str(song['Performer']).partition(" Featuring")[0]
        song['duration'] = song['spotify_track_duration_ms']//1000

        sql_dict_artist = {
            "artist": song['artist'],
        }
        sql_query_artist = sqlalchemy.text("""
            WITH inserted AS (
                INSERT INTO artist (name)
                VALUES (:artist)
                ON CONFLICT (name) DO NOTHING
                RETURNING artist_id
            )
            SELECT artist_id
            FROM inserted
            UNION ALL
            SELECT artist_id
            FROM artist
            WHERE name = :artist                              
            """)
        artist_id = conn.execute(sql_query_artist, sql_dict_artist).scalar()
        sql_dict_album = {
            "album": song['album'],
            "artist_id": artist_id,
        }
        sql_query_album = sqlalchemy.text("""
            WITH inserted AS (
                INSERT INTO album (title, artist_id)
                VALUES (:album, :artist_id)
                ON CONFLICT (title) DO NOTHING
                RETURNING album_id 
            )
            SELECT album_id
            FROM inserted
            UNION ALL
            SELECT album_id
            FROM album
            WHERE title = :album
            """)
        album_id = conn.execute(sql_query_album, sql_dict_album).scalar()
        sql_dict_song = {
            "song": song['name'],
            "artist_id": artist_id,
            "album_id": album_id,
            "duration": song["duration"]
        }
        sql_query_song = sqlalchemy.text("""
            INSERT INTO song (title, album_id, artist_id, duration)
            VALUES (:song, :album_id, :artist_id, :duration)
            """)
        conn.execute(sql_query_song, sql_dict_song)

    print("done\n")
    

    print("creating fake playlists...")
    playlists = []
    total_playlists = 0
    playlist_dist = playlist_sample_distribution(num_users)
    for i in range(num_users):
        
        name = fake.name()
        user_id = conn.execute(sqlalchemy.text("""
        INSERT INTO user_account (first_name, last_name, ssn) VALUES (:first, :last, :ssn) RETURNING user_id;
        """), {"first": name.split()[0], "last":name.split()[1], "ssn":np.random.randint(100000000, 999999999)}).scalar_one()

        num_playlists = playlist_dist[i]
        for j in range(num_playlists):
            total_playlists += 1
            playlists.append({
                "user_id":user_id,
                "playlist_name": generate_playlist_name()
            })


    if playlists:
        conn.execute(sqlalchemy.text("""
        INSERT INTO playlist (user_id, playlist_name) 
        VALUES (:user_id, :playlist_name);
        """), playlists)
    print("Total playlists: ", total_playlists)
    print("done\n")


    print("creating fake collaborators...")
    collaborators = []
    total_collaborators = 0
    collaborators_sample_distribution = np.random.default_rng().negative_binomial(.1, 0.5, total_playlists+1) 
    for i in range(total_playlists):
        num_collaborators = collaborators_sample_distribution[i]
        for j in range(num_collaborators):
            total_collaborators += 1
            collaborators.append({
                "user_id": np.random.randint(1, num_users),
                "playlist_id": i+1
            }
            )

    if collaborators:
        conn.execute(sqlalchemy.text("""
        INSERT INTO playlist_collaborator (playlist_id, user_id) 
        VALUES (:playlist_id, :user_id)
        ON CONFLICT DO NOTHING;
        """), collaborators)
    print("Total collaborators: ", total_collaborators)
    print("done\n")


    print("creating fake followers...")
    followers=[]
    total_followers=0
    follower_dist = follower_sample_distribution(num_users, total_playlists)
    for i in range(total_playlists):
        num_followers = follower_dist[i]
        for j in range(num_followers):
            total_followers += 1
            followers.append({
                "user_id": np.random.randint(1, user_id),
                "playlist_id": i+1
            }
            )

    if followers:
        conn.execute(sqlalchemy.text("""
        INSERT INTO playlist_follower (playlist_id, user_id) 
        VALUES (:playlist_id, :user_id)
        ON CONFLICT DO NOTHING;
        """), followers)
    print("Total followers: ", total_followers)
    print("done\n")


    print("populating playlists...")
    playlist_songs = []
    total_content = 0
    song_count_sample_distribution = np.random.poisson(lam=30, size=total_playlists)
    for i in range(total_playlists):
        num_songs = song_count_sample_distribution[i]
        for j in range(num_songs):
            total_content += 1
            playlist_songs.append({
                "song_id": np.random.randint(1, total_songs),
                "playlist_id": i+1
            }
            )

    if playlist_songs:
        conn.execute(sqlalchemy.text("""
        INSERT INTO playlist_song (song_id, playlist_id) 
        VALUES (:song_id, :playlist_id);
        """), playlist_songs)
    print("Total playlist contents: ", total_content)
    print("done\n")
    
    print("Total songs: ", total_songs)
    print("Total users: ", num_users)
    print("Total playlists: ", total_playlists)
    print("Total followers: ", total_followers)
    print("Total collaborators: ", total_collaborators)
    print("Total playlist contents: ", total_content)